package com.slamdunk.quester2.puzzle;

import java.util.ArrayList;
import java.util.List;

import com.badlogic.gdx.math.MathUtils;
import com.slamdunk.quester.model.points.Point;

/**
 * Gère la représentation logique du puzzle
 */
public class Puzzle {
	public interface PuzzleChangeListener {
		/**
		 * Appelée lorsque 2 attributs ont été échangés.
		 */
		void onAttributesSwitched(int firstX, int firstY, int secondX, int secondY);
		
		/**
		 * Appelée lorsqu'un attribut est créé.
		 */
		void onAttributeCreated(int x, int y, PuzzleAttributes attribute);
		
		/**
		 * Appelée lorsqu'un attribut est supprimé
		 */
		void onAttributeRemoved(int x, int y);
	}
	
	private int width;
	private int height;
	private PuzzleAttributes[][] puzzle;
	
	private PuzzleChangeListener listener;
	
	private boolean isSet;
	
	public Puzzle(int width, int height) {
		this.width = width;
		this.height = height;
		
		// Création du puzzle
		puzzle = new PuzzleAttributes[width][height];
		isSet = false;
	}

	public void setListener(PuzzleChangeListener listener) {
		this.listener = listener;
	}

	/**
	 * Génère un puzzle de départ aléatoire
	 */
	public void init() {
		final PuzzleAttributes[] allAttributes = PuzzleAttributesHelper.BASE_ATTRIBUTES;
		final int randomMax = allAttributes.length - 1;
		PuzzleAttributes attribute;
		for (int y = height - 1; y > -1; y --) {
			for (int x = 0; x < width; x ++) {
				do {
					// Choix d'un attribut aléatoire
					attribute = allAttributes[MathUtils.random(randomMax)];
				}
				// Si les 2 attributs à gauche ou en haut sont identiques, on en choisit un autre
				while (isSameOnLeftOrTop(attribute, x, y, 2));
				
				// Affectation de cet attribut au puzzle
				puzzle[x][y] = attribute;
				
				// Notification du listener
				if (listener != null) {
					listener.onAttributeCreated(x, y, attribute);
				}
			}
		}
		isSet = true;
	}

	/**
	 * Test si l'attribut indiqué se trouve également aux 2 positions voisines
	 * dans la ligne à gauche ou en haut de la position indiquée.
	 */
	private boolean isSameOnLeftOrTop(PuzzleAttributes attribute, int x, int y, int depth) {
		// Teste vers la gauche
		int countLeft = 0;
		for (int cur = x - 1; cur >= x - depth; cur--) {
			if (isValidPos(cur, y) && puzzle[cur][y] == attribute) {
				countLeft ++;
			} else {
				break;
			}
		}
		if (countLeft == depth) {
			return true;
		}
		// Teste vers le haut
		int countTop = 0;
		for (int cur = y + 1; cur <= y + depth; cur++) {
			if (isValidPos(x, cur) && puzzle[x][cur] == attribute) {
				countTop ++;
			} else {
				break;
			}
		}
		if (countTop == depth) {
			return true;
		}
		// Au moins 1 des 2 à gauche et au-dessus n'est pas du même type
		return false;
	}

	/**
	 * Retourne true si la position existe dans le puzzle
	 */
	public boolean isValidPos(int x, int y) {
		return x > -1 && x < width
		&& y > -1 && y < height;
	}

	public int getWidth() {
		return width;
	}

	public int getHeight() {
		return height;
	}
	
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		for (int y = height - 1; y > -1; y --) {
			for (int x = 0; x < width; x ++) {
				sb.append(puzzle[x][y].toString().charAt(0)).append(" ");
			}
			sb.append("\n");
		}
		return sb.toString();
	}

	public PuzzleAttributes get(int x, int y) {
		if (!isValidPos(x, y)) {
			return null;
		}
		return puzzle[x][y];
	}
	

	public PuzzleAttributes remove(int x, int y) {
		if (!isValidPos(x, y)) {
			return null;
		}
		PuzzleAttributes removed = puzzle[x][y];
		puzzle[x][y] = null;
		if (listener != null) {
			listener.onAttributeRemoved(x, y);
		}
		return removed;
	}

	/**
	 * Retourne true si le switch a été autorisé et effectué.
	 */
	public boolean switchAttributes(int firstX, int firstY, int secondX, int secondY) {
		// Inverse les 2 éléments aux positions indiquées
		if (!performSwitch(firstX, firstY, secondX, secondY)) {
			return false;
		}
		
		// Recherche des éventuelles combinaisons
		boolean isFirstAligned = resolveAlignments(firstX, firstY);
		boolean isSecondAligned = resolveAlignments(secondX, secondY);

		if (!isFirstAligned && !isSecondAligned) {
			// Si aucune combinaison n'a été trouvée, on replace les items à leur position initiale
			performSwitch(firstX, firstY, secondX, secondY);
			return false;
		}
		return true;
	}
	
	public void updatePuzzle() {
//		do {
			// Chute des éléments supérieurs
			makeAttributesFall();
			
			// Ajout de nouveaux éléments
			// ...
			
			// Recherche d'éventuelles combinaisons
			// pour chaque élément ajouté ou déplacé
			// ...
		
		// Recommence tant qu'il y a des alignements
//		} while (alignmentFound);
	}

	/**
	 * Fait chuter les attributs, en traitant les attributs depuis le bas du tableau
	 * vers le haut
	 */
	private void makeAttributesFall() {
//		boolean emptyRemains = false;
//		do {
//			emptyRemains = false;
		boolean emptyFound = false;
			for (int y = 0; y < height; y ++) {
				for (int x = 0; x < width; x ++) {
					if (puzzle[x][y] == null) {
						// S'il y a un emplacement au-dessus, on switch
						if (y + 1 < height) {
							performSwitch(x, y, x, y + 1);
//							emptyRemains = true;
						}					
						// Sinon, on est sur la dernière ligne : on ajoute un nouvel attribut
						else {
							puzzle[x][y] = PuzzleAttributesHelper.BASE_ATTRIBUTES[MathUtils.random(PuzzleAttributesHelper.BASE_ATTRIBUTES.length - 1)];
							if (listener != null) {
								listener.onAttributeCreated(x, y, puzzle[x][y]);
							}
						}
						emptyFound = true;
					}
				}
				// On ne fait descendre qu'une ligne à la fois
				if (emptyFound) {
					break;
				}
			}
//		} while (emptyRemains);
	}

	/**
	 * Inverse les attributs aux positions indiquées
	 */
	private boolean performSwitch(int firstX, int firstY, int secondX, int secondY) {
		if (!isValidPos(firstX, firstY) || !isValidPos(secondX, secondY)) {
			return false;
		}
		// Inverse les 2 éléments aux positions indiquées
		PuzzleAttributes tmp = puzzle[firstX][firstY];
		puzzle[firstX][firstY] = puzzle[secondX][secondY];
		puzzle[secondX][secondY] = tmp;
		
		// Prévient le listener afin de faire une jolie inversion
//		if (listener != null) {
//			System.out.printf("Puzzle.switchAttributes() %d %d %d %d\n",firstX, firstY, secondX, secondY);
//			listener.onAttributesSwitched(firstX, firstY, secondX, secondY);
//		}
		return true;
	}

	/**
	 * Vérifie la présence d'alignements comprenant la position indiquée
	 */
	private boolean resolveAlignments(int x, int y) {
		if (!isValidPos(x, y)) {
			return false;
		}
		PuzzleAttributes element = puzzle[x][y];
		List<Point> hAlignedPos = new ArrayList<Point>();
		List<PuzzleAttributes> hAlignedElements = new ArrayList<PuzzleAttributes>();
		List<Point> vAlignedPos = new ArrayList<Point>();
		List<PuzzleAttributes> vAlignedElements = new ArrayList<PuzzleAttributes>();
		
		// Vérifie si l'item participe à un alignement horizontal
		for (int curCol = x; curCol > -1; curCol--) {
			if (!match(curCol, y, element, hAlignedPos, hAlignedElements)) {
				break;
			}
		}
		// On commence à col+1 pour ne pas compter 2 fois la cellule à col;row
		for (int curCol = x + 1; curCol < width; curCol++) {
			if (!match(curCol, y, element, hAlignedPos, hAlignedElements)) {
				break;
			}
		}
		
		// Vérifie si l'item participe à un alignement vertical
		for (int curRow = y; curRow > -1; curRow--) {
			if (!match(x, curRow, element, vAlignedPos, vAlignedElements)) {
				break;
			}
		}
		// On commence à row+1 pour ne pas compter 2 fois la cellule à col;row
		for (int curRow = y + 1; curRow < height; curRow++) {
			if (!match(x, curRow, element, vAlignedPos, vAlignedElements)) {
				break;
			}
		}
		
		// On résoud l'alignement en privilégiant le plus long.
		if (hAlignedPos.size() > 1 && vAlignedPos.size() > 1) {
			return false;
		}
		int hCount = hAlignedPos.size();
		int vCount = vAlignedPos.size();
		if (hCount == vCount) {
			// Formation en coin
			// ...
			return false;
		} else if (hCount > vCount) {
			// Simple ligne horizontale
			return resolveLineAlignment(hAlignedPos, hAlignedElements);
		} else {
			// Simple ligne verticale
			return resolveLineAlignment(vAlignedPos, vAlignedElements);
		}
	}
	
	/**
	 * 
	 */
	private boolean match(int x, int y, PuzzleAttributes element, List<Point> alignedPosList, List<PuzzleAttributes> alignedElementsList) {
		PuzzleAttributes neighborElement = puzzle[x][y];
		if (PuzzleAttributesHelper.areMatchable(neighborElement, element)) {
			alignedPosList.add(new Point(x, y));
			alignedElementsList.add(neighborElement);
			return true;
		}
		return false;
	}
	
	/**
	 * Effectue l'effet liée à la combinaison d'éléments indiquée
	 */
	private boolean resolveLineAlignment(List<Point> alignedPos, List<PuzzleAttributes> alignedElements) {
		// Déclenchement de l'effet adéquat
		PuzzleMatchEffect effect = PuzzleAttributesHelper.getMatchEffect(alignedElements);
		if (effect == null) {
			return false;
		}
		effect.perform(this, alignedPos);
		
		return true;
	}

	/**
	 * Renvoit true si le puzzle a été créé (donc que la méthode init() a été
	 * appelée).
	 * @return
	 */
	public boolean isSet() {
		return isSet;
	}
}
